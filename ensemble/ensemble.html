<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bosque Aleatorio - Aprendizaje Interactivo</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        :root {
            --primary-color: #27ae60;
            --accent-color: #d35400;
            --bg-color: #f8f9fa;
            --card-bg: #ffffff;
            --text-color: #333;
        }

        body {
            font-family: 'Poppins', sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        header {
            background: linear-gradient(135deg, var(--primary-color), #2ecc71);
            color: white;
            padding: 20px;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            position: relative;
        }

        .back-btn {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            color: white;
            text-decoration: none;
            font-weight: 600;
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 15px;
            border-radius: 20px;
            transition: background 0.3s;
        }

        .back-btn:hover {
            background: rgba(255, 255, 255, 0.4);
        }

        .container {
            max-width: 1400px;
            margin: 30px auto;
            padding: 0 20px;
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 20px;
        }

        .sidebar {
            background: var(--card-bg);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            height: fit-content;
        }

        .tree-control-card {
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            background: #fafafa;
            border-left: 4px solid var(--primary-color);
        }

        .tree-control-card h4 {
            margin: 0 0 10px 0;
            color: var(--primary-color);
            display: flex;
            justify-content: space-between;
        }

        .control-group {
            margin-bottom: 10px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.85em;
            font-weight: 600;
        }

        input[type="range"],
        select {
            width: 100%;
        }

        .value-display {
            color: var(--accent-color);
            float: right;
            font-weight: bold;
        }

        .btn-predict {
            width: 100%;
            padding: 12px;
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            font-size: 1.1em;
            margin-top: 10px;
            transition: 0.2s;
        }

        .btn-predict:hover {
            transform: scale(1.02);
            filter: brightness(1.1);
        }

        .main-content {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .score-board {
            background: linear-gradient(135deg, #2c3e50, var(--primary-color));
            color: white;
            padding: 20px;
            border-radius: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .score-board h2 {
            margin: 0 0 5px 0;
            font-size: 1.4em;
        }

        .score-board p {
            margin: 0;
            font-size: 0.9em;
            opacity: 0.9;
        }

        .score-value {
            font-size: 2.2em;
            font-weight: 800;
            background: rgba(255, 255, 255, 0.2);
            padding: 10px 20px;
            border-radius: 8px;
            transition: background-color 0.3s;
        }

        .plot-card {
            background: var(--card-bg);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }

        .trees-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .tree-plot {
            height: 300px;
            border: 1px solid #eee;
            border-radius: 5px;
        }

        #bootstrapPlot {
            height: 350px;
        }

        #ensemblePlot {
            height: 450px;
            border: 2px solid var(--primary-color);
            border-radius: 8px;
        }

        .joyful-note {
            background: #e8f8f5;
            padding: 10px;
            border-radius: 5px;
            font-size: 0.9em;
            text-align: center;
            margin-bottom: 10px;
        }
    </style>
</head>

<body>

    <header>
        <a href="../index.html" class="back-btn">‚Üê Volver</a>
        <h1>üå≤ Bosque Aleatorio Interactivo</h1>
        <p>Predicci√≥n de Mora Crediticia bas√°ndonos en Ingresos vs. Endeudamiento</p>
    </header>

    <div class="container">
        <aside class="sidebar">
            <h3>Controles del Bosque</h3>
            <p style="font-size: 0.8em; color: #7f8c8d;">Ajusta la personalidad de cada √°rbol. ¬°Observa c√≥mo al limitar
                su profundidad o sus variables cambia su forma de ver los datos!</p>

            <div id="treeControls"></div>

            <button class="btn-predict" onclick="growForest()">üé≤ ¬°Regenerar Bosque!</button>
            <p style="font-size: 0.75em; text-align:center; margin-top:10px; color:#95a5a6;">Al hacer clic, se extraen
                nuevas muestras de datos (bootstrapping) y se reentrenan los √°rboles.</p>
        </aside>

        <main class="main-content">

            <div class="score-board">
                <div>
                    <h2>üéØ Tu Objetivo: Minimizar el Error</h2>
                    <p>Ajusta el nivel de profundidad y las variables de cada √°rbol para reducir el error de
                        clasificaci√≥n del Ensamble.</p>
                </div>
                <div class="score-value" id="ensembleError">0.0%</div>
            </div>

            <div class="plot-card">
                <h3>üéâ 1. La Magia del Bootstrapping</h3>
                <div class="joyful-note">
                    <strong>¬øC√≥mo funciona?</strong> Entregamos a cada √°rbol una muestra aleatoria de clientes <em>con
                        reemplazo</em>.<br>
                    üü¢/üü† <strong>Puntos Grandes:</strong> Clientes seleccionados m√∫ltiples veces en la misma
                    muestra.<br>
                    üîò <strong>Puntos Grises:</strong> "Out-of-Bag" (Clientes que este √°rbol en particular no lleg√≥ a
                    ver).
                </div>
                <div id="bootstrapPlot"></div>
            </div>

            <div class="plot-card">
                <h3>üå≥ 2. Los Cuatro √Årboles (Generalistas y Especialistas)</h3>
                <div class="joyful-note">
                    Notar√°s que algunos √°rboles toman decisiones sobre todos los ejes simult√°neamente
                    (<strong>Generalistas</strong>), mientras que otros solo pueden usar un eje a la vez en cada
                    divisi√≥n de manera aleatoria (<strong>Especialistas</strong>). ¬°Esta diferencia de perspectivas es
                    la clave de un buen ensamble!
                </div>
                <div class="trees-grid">
                    <div id="tree1" class="tree-plot"></div>
                    <div id="tree2" class="tree-plot"></div>
                    <div id="tree3" class="tree-plot"></div>
                    <div id="tree4" class="tree-plot"></div>
                </div>
            </div>

            <div class="plot-card">
                <h3>üëë 3. El Ensamblaje (Voto Mayoritario)</h3>
                <div class="joyful-note">Cuando los 4 √°rboles exc√©ntricos combinan sus votos, logran una frontera de
                    decisi√≥n mucho m√°s suave y l√≥gica para separar a los clientes "Al D√≠a" de los clientes en "Mora".
                </div>
                <div id="ensemblePlot"></div>
            </div>

        </main>
    </div>

    <script>
        // --- 1. Synthesize Dataset (Mora Crediticia) ---
        // Eje X: Ingresos ($)
        // Eje Y: Monto de Endeudamiento ($)
        const N = 150;
        const dataset = [];

        for (let i = 0; i < N; i++) {
            let classLabel = i < N / 2 ? 0 : 1; // 0: Al d√≠a (Verde), 1: Mora (Naranja)
            let ingresos, deuda;

            if (classLabel === 0) {
                // Al d√≠a: Ingresos m√°s altos, Deuda m√°s baja
                ingresos = 30000 + Math.random() * 70000; // 30k a 100k
                deuda = 1000 + Math.random() * 25000;     // 1k a 26k
            } else {
                // Mora: Ingresos m√°s bajos, Deuda m√°s alta
                ingresos = 10000 + Math.random() * 50000; // 10k a 60k
                deuda = 15000 + Math.random() * 35000;    // 15k a 50k
            }

            dataset.push([ingresos, deuda, classLabel]);
        }

        // --- 2. JS Decision Tree Implementation (CART) ---
        function giniIndex(groups, classes) {
            let nInstances = groups[0].length + groups[1].length;
            let gini = 0.0;
            for (let group of groups) {
                let size = group.length;
                if (size === 0) continue;
                let score = 0.0;
                for (let c of classes) {
                    let p = group.filter(row => row[2] === c).length / size;
                    score += p * p;
                }
                gini += (1.0 - score) * (size / nInstances);
            }
            return gini;
        }

        function testSplit(index, value, data) {
            let left = [], right = [];
            for (let row of data) {
                if (row[index] < value) left.push(row);
                else right.push(row);
            }
            return [left, right];
        }

        function getSplit(data, maxFeatures) {
            let classes = [0, 1];
            let bIndex = 999, bValue = 999, bScore = 999, bGroups = null;

            let features = [0, 1];
            if (maxFeatures === 1) {
                features = [Math.random() < 0.5 ? 0 : 1];
            }

            for (let index of features) {
                for (let row of data) {
                    let groups = testSplit(index, row[index], data);
                    let gini = giniIndex(groups, classes);
                    if (gini < bScore) {
                        bIndex = index;
                        bValue = row[index];
                        bScore = gini;
                        bGroups = groups;
                    }
                }
            }
            return { index: bIndex, value: bValue, groups: bGroups };
        }

        function toTerminal(group) {
            let outcomes = group.map(row => row[2]);
            return outcomes.filter(v => v === 0).length > outcomes.filter(v => v === 1).length ? 0 : 1;
        }

        function split(node, maxDepth, minSize, depth, maxFeatures) {
            let left = node.groups[0];
            let right = node.groups[1];
            delete node.groups;

            if (left.length === 0 || right.length === 0) {
                node.left = node.right = toTerminal(left.concat(right));
                return;
            }
            if (depth >= maxDepth) {
                node.left = toTerminal(left);
                node.right = toTerminal(right);
                return;
            }
            if (left.length <= minSize) node.left = toTerminal(left);
            else {
                node.left = getSplit(left, maxFeatures);
                split(node.left, maxDepth, minSize, depth + 1, maxFeatures);
            }
            if (right.length <= minSize) node.right = toTerminal(right);
            else {
                node.right = getSplit(right, maxFeatures);
                split(node.right, maxDepth, minSize, depth + 1, maxFeatures);
            }
        }

        function buildTree(data, maxDepth, maxFeatures) {
            let root = getSplit(data, maxFeatures);
            split(root, maxDepth, 1, 1, maxFeatures);
            return root;
        }

        function predictTree(node, row) {
            if (row[node.index] < node.value) {
                if (typeof node.left === 'object') return predictTree(node.left, row);
                else return node.left;
            } else {
                if (typeof node.right === 'object') return predictTree(node.right, row);
                else return node.right;
            }
        }

        // --- 3. Bootstrapping Logic ---
        function bootstrapSample(data) {
            let sample = [];
            let counts = new Array(data.length).fill(0);
            for (let i = 0; i < data.length; i++) {
                let idx = Math.floor(Math.random() * data.length);
                sample.push(data[idx]);
                counts[idx]++;
            }
            return { sample, counts };
        }

        // --- 4. UI Setup & Plotting ---
        const treesConfig = [
            { id: 1, type: 'Generalista 1', depth: 3, features: 2, color: '#1abc9c', desc: '(Usa ambas variables)' },
            { id: 2, type: 'Especialista 1', depth: 4, features: 1, color: '#3498db', desc: '(Usa 1 sola variable)' },
            { id: 3, type: 'Generalista 2', depth: 2, features: 2, color: '#9b59b6', desc: '(Usa ambas variables)' },
            { id: 4, type: 'Especialista 2', depth: 5, features: 1, color: '#e74c3c', desc: '(Usa 1 sola variable)' }
        ];

        function initUI() {
            const container = document.getElementById('treeControls');
            treesConfig.forEach(t => {
                container.innerHTML += `
                    <div class="tree-control-card" style="border-left-color: ${t.color}">
                        <h4>${t.type} <span style="font-size:0.8em; font-weight:normal; color:#7f8c8d">${t.desc}</span></h4>
                        <div class="control-group">
                            <label>Profundidad M√°xima: <span id="val_d${t.id}" class="value-display">${t.depth}</span></label>
                            <input type="range" id="d${t.id}" min="1" max="10" value="${t.depth}" oninput="updateVal('d${t.id}')">
                        </div>
                        <div class="control-group">
                            <label>Variables Evaluadas:</label>
                            <select id="f${t.id}">
                                <option value="1" ${t.features === 1 ? 'selected' : ''}>1 (Solo 1 Eje Aleatorio)</option>
                                <option value="2" ${t.features === 2 ? 'selected' : ''}>2 (La Mejor de Ambas)</option>
                            </select>
                        </div>
                    </div>
                `;
            });
        }

        window.updateVal = function (id) {
            document.getElementById('val_' + id).innerText = document.getElementById(id).value;
        }

        let forest = [];
        let gridX = [], gridY = [];

        // Create meshgrid for contours based on Income (10k-100k) and Debt (0-55k)
        for (let x = 5000; x <= 105000; x += 3000) {
            for (let y = 0; y <= 55000; y += 1500) {
                gridX.push(x); gridY.push(y);
            }
        }

        function drawPlot(divId, modelPredict, title, isEnsemble = false, overlayData = dataset) {
            let zVals = [];
            for (let i = 0; i < gridX.length; i++) {
                zVals.push(modelPredict([gridX[i], gridY[i]]));
            }

            const contour = {
                x: gridX, y: gridY, z: zVals,
                type: 'contour',
                colorscale: isEnsemble ? [[0, '#27ae60'], [0.5, '#ffffff'], [1, '#d35400']] : [[0, '#a9dfbf'], [1, '#f5b041']],
                opacity: 0.5,
                showscale: false,
                hoverinfo: 'none'
            };

            const scatter = {
                x: overlayData.map(d => d[0]),
                y: overlayData.map(d => d[1]),
                mode: 'markers',
                marker: {
                    color: overlayData.map(d => d[2] === 0 ? '#27ae60' : '#d35400'),
                    size: 6,
                    line: { color: 'white', width: 1 }
                },
                type: 'scatter',
                name: 'Clientes'
            };

            const layout = {
                title: { text: title, font: { size: 13 } },
                margin: { t: 30, b: isEnsemble ? 40 : 20, l: isEnsemble ? 50 : 20, r: 20 },
                xaxis: {
                    title: isEnsemble ? 'Ingresos ($)' : '',
                    showgrid: false, zeroline: false,
                    showticklabels: isEnsemble
                },
                yaxis: {
                    title: isEnsemble ? 'Deuda ($)' : '',
                    showgrid: false, zeroline: false,
                    showticklabels: isEnsemble
                },
                showlegend: false
            };

            Plotly.react(divId, [contour, scatter], layout);
        }

        function drawBootstrap(counts) {
            let colors = [], sizes = [], opacities = [];

            for (let i = 0; i < dataset.length; i++) {
                if (counts[i] === 0) {
                    colors.push('#bdc3c7'); // Gris para "Fuera de la bolsa"
                    sizes.push(6);
                    opacities.push(0.5);
                } else {
                    colors.push(dataset[i][2] === 0 ? '#27ae60' : '#d35400');
                    sizes.push(8 + (counts[i] * 5)); // M√°s grande si se seleccion√≥ m√°s veces
                    opacities.push(0.9);
                }
            }

            const trace = {
                x: dataset.map(d => d[0]),
                y: dataset.map(d => d[1]),
                mode: 'markers',
                marker: { color: colors, size: sizes, opacity: opacities, line: { color: '#fff', width: 1 } },
                type: 'scatter',
                text: counts.map(c => c === 0 ? 'Fuera de la bolsa' : `Seleccionado ${c} veces`),
                hoverinfo: 'text'
            };

            const layout = {
                margin: { t: 10, b: 40, l: 50, r: 10 },
                xaxis: { title: 'Ingresos ($)', showgrid: false, zeroline: false },
                yaxis: { title: 'Deuda ($)', showgrid: false, zeroline: false }
            };

            Plotly.react('bootstrapPlot', [trace], layout);
        }

        window.growForest = function () {
            forest = [];
            let lastCounts;

            treesConfig.forEach((t, index) => {
                let depth = parseInt(document.getElementById(`d${t.id}`).value);
                let feats = parseInt(document.getElementById(`f${t.id}`).value);

                let boot = bootstrapSample(dataset);
                if (index === 0) lastCounts = boot.counts; // Mostrar la muestra del √Årbol 1

                let tree = buildTree(boot.sample, depth, feats);
                forest.push(tree);

                drawPlot(`tree${t.id}`, (row) => predictTree(tree, row), `${t.type} (Prof: ${depth}, Vars: ${feats})`);
            });

            drawBootstrap(lastCounts);

            // Ensemble Prediction (Promedio de los votos)
            drawPlot('ensemblePlot', (row) => {
                let votes = forest.map(tree => predictTree(tree, row));
                let sum = votes.reduce((a, b) => a + b, 0);
                return sum / forest.length; // Retorna probabilidad [0, 1]
            }, 'Frontera de Decisi√≥n del Bosque Aleatorio', true);

            // Calcular Error del Ensamble y actualizar Scoreboard
            let errors = 0;
            dataset.forEach(row => {
                let votes = forest.map(tree => predictTree(tree, row));
                let sum = votes.reduce((a, b) => a + b, 0);
                let prob = sum / forest.length;
                let pred = prob > 0.5 ? 1 : 0; // Umbral de decisi√≥n
                // Si hay empate estricto (prob = 0.5), sumamos medio error
                if (prob === 0.5) {
                    errors += 0.5;
                } else if (pred !== row[2]) {
                    errors += 1;
                }
            });
            let errorRate = ((errors / dataset.length) * 100).toFixed(1);

            const errorElement = document.getElementById('ensembleError');
            errorElement.innerText = errorRate + '% Error';

            // Retroalimentaci√≥n visual interactiva
            if (errorRate < 10) {
                errorElement.style.backgroundColor = 'rgba(46, 204, 113, 0.9)'; // Verde √©xito
            } else if (errorRate < 20) {
                errorElement.style.backgroundColor = 'rgba(243, 156, 18, 0.9)'; // Naranja advertencia
            } else {
                errorElement.style.backgroundColor = 'rgba(231, 76, 60, 0.9)'; // Rojo error
            }
        }

        // Initialize
        initUI();
        growForest();

    </script>
</body>

</html>