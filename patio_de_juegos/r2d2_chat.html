<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transmisión de Datos Acústicos R2D2</title>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        :root {
            --r2-blue: #0074D9;
            --r2-white: #DDDDDD;
            --r2-silver: #AAAAAA;
            --screen-bg: #111;
            --text-glow: 0 0 5px var(--r2-blue);
        }

        body {
            background-color: #050505;
            color: var(--r2-white);
            font-family: 'Share Tech Mono', monospace;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        header {
            text-align: center;
            margin-top: 20px;
            padding: 20px;
            border-bottom: 2px solid var(--r2-blue);
            width: 90%;
            max-width: 800px;
        }

        h1 {
            color: var(--r2-blue);
            text-shadow: var(--text-glow);
            margin: 0;
            font-size: 2em;
        }

        .container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            width: 90%;
            max-width: 1000px;
            margin-top: 30px;
        }

        .panel {
            background: #1a1a1a;
            border: 1px solid var(--r2-silver);
            border-radius: 10px;
            padding: 20px;
            width: 100%;
            max-width: 450px;
            box-shadow: 0 0 10px rgba(0, 116, 217, 0.2);
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            color: var(--r2-blue);
            border-bottom: 1px solid var(--r2-silver);
            padding-bottom: 10px;
            margin-bottom: 15px;
            font-size: 1.2em;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        textarea {
            background: var(--screen-bg);
            color: #0f0;
            border: 1px solid #333;
            padding: 10px;
            font-family: inherit;
            resize: none;
            height: 100px;
            margin-bottom: 15px;
            border-radius: 5px;
        }

        button {
            background: var(--r2-blue);
            color: white;
            border: none;
            padding: 10px 20px;
            font-family: inherit;
            font-size: 1em;
            cursor: pointer;
            border-radius: 5px;
            transition: background 0.3s, transform 0.1s;
        }

        button:hover {
            background: #0056b3;
            transform: scale(1.05);
        }

        button:active {
            transform: scale(0.95);
        }

        button:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
        }

        #visualizer {
            background: var(--screen-bg);
            border: 1px solid #333;
            width: 100%;
            height: 150px;
            border-radius: 5px;
            margin-bottom: 15px;
        }

        #decoded-text {
            color: #0ff;
            min-height: 50px;
            font-size: 1.1em;
            white-space: pre-wrap;
        }

        .status-light {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #333;
            display: inline-block;
            box-shadow: 0 0 2px #000;
        }

        .status-light.active {
            background: #f00;
            box-shadow: 0 0 8px #f00;
        }

        .status-light.receiving {
            background: #0f0;
            box-shadow: 0 0 8px #0f0;
        }

        .instructions {
            margin-top: 10px;
            font-size: 0.8em;
            color: #888;
        }

        .back-link {
            margin-top: 40px;
            margin-bottom: 20px;
        }

        .back-link a {
            color: var(--r2-silver);
            text-decoration: none;
        }

        .back-link a:hover {
            color: var(--r2-blue);
            text-decoration: underline;
        }
    </style>
</head>

<body>

    <header>
        <h1>Consola de Interfaz R2D2</h1>
        <div class="instructions">Protocolo de Comunicación Astromecánica v3.7</div>
    </header>

    <div class="container">
        <!-- TX Panel -->
        <div class="panel">
            <div class="panel-header">
                <span>TRANSMISIÓN (TX)</span>
                <div id="tx-light" class="status-light"></div>
            </div>
            <textarea id="input-text" placeholder="Escriba el mensaje para el droide..."></textarea>
            <button id="btn-transmit">TRANSMITIR DATOS</button>
            <div class="instructions">Convierte texto humano a binario astromecánico.</div>
        </div>

        <!-- RX Panel -->
        <div class="panel">
            <div class="panel-header">
                <span>RECEPCIÓN (RX)</span>
                <div id="rx-light" class="status-light"></div>
            </div>
            <canvas id="visualizer"></canvas>
            <div id="decoded-output">
                <span style="color:#666;">> MENSAJE DECODIFICADO:</span>
                <div id="decoded-text"></div>
            </div>
            <button id="btn-listen" style="margin-top: 10px;">ACTIVAR MICRÓFONO</button>
        </div>
    </div>

    <div class="back-link">
        <a href="../index.html">← Volver al Dashboard</a>
    </div>

    <script>
        // --- AUDIO CONTEXT SETUP ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx;
        let analyser;
        let microphoneStream;
        let visualizerCtx;
        let isListening = false;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new AudioContext();
            }
        }

        // --- R2D2 SOUND GENERATION (TX) ---
        // Generates random beeps and whistles to simulate speech
        const btnTransmit = document.getElementById('btn-transmit');
        const txLight = document.getElementById('tx-light');

        async function playTone(freq, type, duration, slideTo = null) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            osc.type = type; // sine, square, sawtooth, triangle
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);

            if (slideTo) {
                osc.frequency.exponentialRampToValueAtTime(slideTo, audioCtx.currentTime + duration);
            }

            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);

            osc.connect(gain);
            gain.connect(audioCtx.destination);

            osc.start();
            osc.stop(audioCtx.currentTime + duration);

            return new Promise(resolve => setTimeout(resolve, duration * 1000));
        }

        async function generateR2Speech(text) {
            // Number of sounds roughly based on text length, but random for effect
            const numSounds = Math.max(3, Math.ceil(text.length / 2));

            txLight.classList.add('active');
            btnTransmit.disabled = true;

            for (let i = 0; i < numSounds; i++) {
                // Randomize parameters
                const duration = Math.random() * 0.15 + 0.05; // 50ms to 200ms
                const freq = Math.random() * 1500 + 500; // 500Hz to 2000Hz
                const types = ['sine', 'square', 'sawtooth', 'triangle'];
                const type = types[Math.floor(Math.random() * types.length)];

                // Occasional slide effect (whistle)
                const isSlide = Math.random() > 0.7;
                const slideTo = isSlide ? (Math.random() * 1000 + 500) : null;

                await playTone(freq, type, duration, slideTo);

                // Small pause between some beeps
                if (Math.random() > 0.5) {
                    await new Promise(r => setTimeout(r, Math.random() * 50 + 20));
                }
            }

            txLight.classList.remove('active');
            btnTransmit.disabled = false;
        }

        btnTransmit.addEventListener('click', () => {
            initAudio();
            const text = document.getElementById('input-text').value;
            if (text.trim() === "") return;

            // Resume context if suspended (browser autoplay policy)
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }

            generateR2Speech(text);
        });


        // --- MICROPHONE VISUALIZATION & DECODING (RX) ---
        const btnListen = document.getElementById('btn-listen');
        const canvas = document.getElementById('visualizer');
        const canvasCtx = canvas.getContext('2d');
        const rxLight = document.getElementById('rx-light');
        const decodedTextDiv = document.getElementById('decoded-text');

        // Hypothetical R2 responses
        const r2Responses = [
            "Afirmativo, comando recibido.",
            "¡Bip bop bip! Sistema funcional.",
            "Cuidado, niveles de energía bajos.",
            "Detectando anomalía en el sector 7.",
            "¡Woooooooo!", // Excited scream
            "Procesando...",
            "Negativo. No puedo hacer eso.",
            "La Fuerza es fuerte en este código.",
            "Escaneando formas de vida...",
            "Bip... bop... ¿Hola?",
            "Transmisión iniciada."
        ];

        async function startListening() {
            initAudio();
            if (audioCtx.state === 'suspended') {
                await audioCtx.resume();
            }

            try {
                microphoneStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const source = audioCtx.createMediaStreamSource(microphoneStream);
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 2048;
                source.connect(analyser);

                isListening = true;
                btnListen.textContent = "DETENER ESCUCHA";
                btnListen.style.background = "#d32f2f";
                rxLight.classList.add('receiving');
                decodedTextDiv.textContent = ""; // Clear previous

                drawVisualizer();

                // Simulate "decoding" after random time if sound is detected
                // For this demo, we just wait a bit and show a random message if loud enough
                checkForSound();

            } catch (err) {
                console.error("Error accessing microphone:", err);
                alert("No se pudo acceder al micrófono.");
            }
        }

        function stopListening() {
            if (microphoneStream) {
                microphoneStream.getTracks().forEach(track => track.stop());
            }
            isListening = false;
            btnListen.textContent = "ACTIVAR MICRÓFONO";
            btnListen.style.background = ""; // Reset to default CSS
            rxLight.classList.remove('receiving');
            cancelAnimationFrame(drawVisualFrame);

            // Clear canvas
            canvasCtx.fillStyle = '#111';
            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
        }

        btnListen.addEventListener('click', () => {
            if (isListening) {
                stopListening();
            } else {
                startListening();
            }
        });

        let drawVisualFrame;

        function drawVisualizer() {
            if (!isListening) return;
            drawVisualFrame = requestAnimationFrame(drawVisualizer);

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteTimeDomainData(dataArray);

            canvasCtx.fillStyle = '#111';
            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

            canvasCtx.lineWidth = 2;
            canvasCtx.strokeStyle = '#0074D9';
            canvasCtx.beginPath();

            const sliceWidth = canvas.width * 1.0 / bufferLength;
            let x = 0;

            for (let i = 0; i < bufferLength; i++) {
                const v = dataArray[i] / 128.0;
                const y = v * canvas.height / 2;

                if (i === 0) {
                    canvasCtx.moveTo(x, y);
                } else {
                    canvasCtx.lineTo(x, y);
                }

                x += sliceWidth;
            }

            canvasCtx.lineTo(canvas.width, canvas.height / 2);
            canvasCtx.stroke();
        }

        // Simple heuristic to "Decode" speech
        function checkForSound() {
            if (!isListening) return;

            const checkInterval = 100; // ms
            const threshold = 135; // Amplitude threshold (128 is silence)

            const listener = setInterval(() => {
                if (!isListening) {
                    clearInterval(listener);
                    return;
                }

                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                analyser.getByteTimeDomainData(dataArray);

                // Check if any sample exceeds threshold (noise detected)
                const isLoud = dataArray.some(v => v > threshold || v < (256 - threshold));

                if (isLoud) {
                    // "Decoding" logic
                    if (Math.random() > 0.95) { // 5% chance per 100ms when loud
                        const msg = r2Responses[Math.floor(Math.random() * r2Responses.length)];

                        // Typewriter effect
                        decodedTextDiv.textContent = "";
                        let charIndex = 0;
                        clearInterval(listener); // Stop checking while printing

                        const typeInterval = setInterval(() => {
                            decodedTextDiv.textContent += msg.charAt(charIndex);
                            charIndex++;
                            if (charIndex >= msg.length) {
                                clearInterval(typeInterval);
                                // Resume listening for new sounds after delay
                                setTimeout(() => checkForSound(), 2000);
                            }
                        }, 50);
                    }
                }
            }, checkInterval);
        }

    </script>
</body>

</html>